import unittest
from unittest.mock import patch, Mock
from sql_injection_tester import test_sql_injection, analyze_sql_injection, parse_tables_columns, extract_sensitive_data

class TestSQLInjectionTester(unittest.TestCase):

    @patch('sql_injection_tester.requests.get')
    def test_test_sql_injection(self, mock_get):
        mock_get.return_value.status_code = 200
        mock_get.return_value.text = "SQL syntax error"
        self.assertTrue(test_sql_injection("http://example.com"))

        mock_get.return_value.text = "No SQL error"
        self.assertFalse(test_sql_injection("http://example.com"))

    @patch('sql_injection_tester.requests.get')
    def test_analyze_sql_injection(self, mock_get):
        mock_get.return_value.status_code = 200
        mock_get.return_value.text = "<table><tr><td>table_name</td><td>column_name</td></tr></table>"
        analyze_sql_injection("http://example.com", "' OR '1'='1")
        mock_get.assert_called()

    def test_parse_tables_columns(self):
        html_content = "<table><tr><td>table1</td><td>column1</td></tr><tr><td>table2</td><td>column2</td></tr></table>"
        result = parse_tables_columns(html_content)
        expected = {
            "table1": ["column1"],
            "table2": ["column2"]
        }
        self.assertEqual(result, expected)

    @patch('sql_injection_tester.requests.get')
    def test_extract_sensitive_data(self, mock_get):
        mock_get.return_value.status_code = 200
        mock_get.return_value.text = "sensitive data"
        tables_columns = {
            "table1": ["column1"]
        }
        extract_sensitive_data("http://example.com", tables_columns)
        mock_get.assert_called()

if __name__ == '__main__':
    unittest.main()
